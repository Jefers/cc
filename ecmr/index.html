<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meter Reader</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiTWV0ZXIgUmVhZGVyIiwic2hvcnRfbmFtZSI6Ik1ldGVyUmVhZGVyIiwic3RhcnRfdXJsIjoiLyIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwiYmFja2dyb3VuZF9jb2xvciI6IiMxZjJmMzgiLCJ0aGVtZV9jb2xvciI6IiMzYjgyZjYiLCJpY29ucyI6W3sic3JjIjoiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpRaUlHaGxhV2QwYUQwaU1qUWlJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lnWm1sc2JEMGlJek0zTkRjMlppSStQR052Y21zbGEyRnRhSE5xY25Sc1ptRXBMemh5Um1ScFFsRlNabXN2UGlCYmIyeFdKMGRyZGpGR2JYUjdKU1E9IiwicmVmc3MiOiI1MTJANTEyIiwidHlwZSI6ImltYWdlL3N2Zyt4bWwifV19">
    <meta name="theme-color" content="#3b82f6">
    <style>
        .loading-spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .fade-in {
            animation: fadeIn 0.3s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .cropper-container {
            max-height: 400px;
        }
        
        .reading-item {
            transition: all 0.2s ease;
        }
        
        .reading-item:hover {
            transform: translateX(4px);
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div id="app" class="container mx-auto max-w-md px-4 py-6">
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-3xl font-bold text-gray-800 mb-2">‚ö° Meter Reader</h1>
            <p class="text-gray-600">Track your electricity meter readings</p>
        </header>

        <!-- Main Screen -->
        <div id="mainScreen" class="space-y-6">
            <!-- Read Meter Button -->
            <div class="text-center">
                <button id="readMeterBtn" 
                        class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-4 px-8 rounded-xl text-lg shadow-lg transform transition-all duration-200 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-300"
                        aria-label="Start meter reading process">
                    üì∑ Read Meter
                </button>
            </div>

            <!-- Quick Stats -->
            <div id="quickStats" class="bg-white rounded-xl p-4 shadow-md">
                <h2 class="text-lg font-semibold text-gray-800 mb-3">üìä Quick Stats</h2>
                <div class="grid grid-cols-2 gap-4 text-sm">
                    <div class="text-center">
                        <div class="font-bold text-2xl text-blue-600" id="totalReadings">0</div>
                        <div class="text-gray-600">Total Readings</div>
                    </div>
                    <div class="text-center">
                        <div class="font-bold text-2xl text-green-600" id="lastReading">-</div>
                        <div class="text-gray-600">Last Reading</div>
                    </div>
                </div>
            </div>

            <!-- Recent Readings -->
            <div class="bg-white rounded-xl p-4 shadow-md">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-lg font-semibold text-gray-800">üìã Recent Readings</h2>
                    <button id="clearHistoryBtn" class="text-red-500 text-sm hover:text-red-700 focus:outline-none">
                        Clear All
                    </button>
                </div>
                <div id="readingsList" class="space-y-3">
                    <div class="text-gray-500 text-center py-8">
                        No readings yet. Take your first photo!
                    </div>
                </div>
            </div>
        </div>

        <!-- Camera Screen -->
        <div id="cameraScreen" class="hidden">
            <div class="text-center mb-4">
                <h2 class="text-xl font-bold text-gray-800">üì∑ Capture Meter Photo</h2>
                <p class="text-gray-600 text-sm mt-2">Position the meter display in the frame</p>
            </div>
            
            <div class="bg-white rounded-xl p-4 shadow-md mb-4">
                <input type="file" id="cameraInput" accept="image/*" capture="environment" 
                       class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                <div class="text-xs text-gray-500 mt-2">
                    üí° Tip: Ensure good lighting and clear view of digits
                </div>
            </div>
            
            <div class="flex gap-3">
                <button id="cancelCameraBtn" 
                        class="flex-1 bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-4 rounded-lg">
                    Cancel
                </button>
            </div>
        </div>

        <!-- Crop Screen -->
        <div id="cropScreen" class="hidden">
            <div class="text-center mb-4">
                <h2 class="text-xl font-bold text-gray-800">‚úÇÔ∏è Crop Meter Digits</h2>
                <p class="text-gray-600 text-sm mt-2">Select the area with the meter reading</p>
            </div>
            
            <div class="bg-white rounded-xl p-4 shadow-md mb-4">
                <div class="cropper-container">
                    <img id="cropImage" style="max-width: 100%; display: block;">
                </div>
            </div>
            
            <div class="flex gap-3">
                <button id="cancelCropBtn" 
                        class="flex-1 bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-4 rounded-lg">
                    Back
                </button>
                <button id="confirmCropBtn" 
                        class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg">
                    Extract Reading
                </button>
            </div>
        </div>

        <!-- OCR Processing Screen -->
        <div id="ocrScreen" class="hidden">
            <div class="text-center mb-6">
                <h2 class="text-xl font-bold text-gray-800">üîç Extracting Reading...</h2>
                <div class="flex justify-center items-center mt-4">
                    <div class="loading-spinner"></div>
                    <span class="ml-3 text-gray-600">Processing image...</span>
                </div>
            </div>
        </div>

        <!-- Confirm Reading Screen -->
        <div id="confirmScreen" class="hidden">
            <div class="text-center mb-4">
                <h2 class="text-xl font-bold text-gray-800">‚úÖ Confirm Reading</h2>
                <p class="text-gray-600 text-sm mt-2">Verify or correct the extracted value</p>
            </div>
            
            <div class="bg-white rounded-xl p-4 shadow-md mb-4">
                <div class="mb-4">
                    <img id="croppedPreview" class="w-full max-h-32 object-contain rounded-lg border">
                </div>
                
                <div class="mb-4">
                    <label class="block text-gray-700 text-sm font-bold mb-2">
                        Meter Reading (kWh):
                    </label>
                    <input type="number" id="readingInput" 
                           class="w-full p-3 text-xl text-center border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                           placeholder="Enter reading">
                    <div class="text-xs text-gray-500 mt-1">
                        Edit if OCR reading is incorrect
                    </div>
                </div>
                
                <div class="text-sm text-gray-600 mb-4">
                    <div>üìÖ Date: <span id="currentDate"></span></div>
                    <div>üïê Time: <span id="currentTime"></span></div>
                </div>
            </div>
            
            <div class="flex gap-3">
                <button id="cancelConfirmBtn" 
                        class="flex-1 bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-4 rounded-lg">
                    Cancel
                </button>
                <button id="saveReadingBtn" 
                        class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg">
                    Save Reading
                </button>
            </div>
        </div>

        <!-- Error Messages -->
        <div id="errorMessage" class="hidden fixed top-4 left-4 right-4 bg-red-500 text-white p-4 rounded-lg shadow-lg z-50">
            <div class="flex justify-between items-center">
                <span id="errorText"></span>
                <button id="closeError" class="text-white hover:text-gray-200 text-xl">&times;</button>
            </div>
        </div>

        <!-- Success Messages -->
        <div id="successMessage" class="hidden fixed top-4 left-4 right-4 bg-green-500 text-white p-4 rounded-lg shadow-lg z-50">
            <div class="flex justify-between items-center">
                <span id="successText"></span>
                <button id="closeSuccess" class="text-white hover:text-gray-200 text-xl">&times;</button>
            </div>
        </div>
    </div>

    <script>
        class MeterReaderApp {
            constructor() {
                this.currentImage = null;
                this.cropper = null;
                this.readings = this.loadReadings();
                this.initializeApp();
            }

            initializeApp() {
                this.setupEventListeners();
                this.updateStats();
                this.renderReadings();
                this.registerServiceWorker();
                console.log('Meter Reader App initialized');
            }

            setupEventListeners() {
                // Main navigation
                document.getElementById('readMeterBtn').addEventListener('click', () => this.showCameraScreen());
                document.getElementById('cancelCameraBtn').addEventListener('click', () => this.showMainScreen());
                document.getElementById('cancelCropBtn').addEventListener('click', () => this.showCameraScreen());
                document.getElementById('cancelConfirmBtn').addEventListener('click', () => this.showMainScreen());
                
                // Camera input
                document.getElementById('cameraInput').addEventListener('change', (e) => this.handleImageCapture(e));
                
                // Crop actions
                document.getElementById('confirmCropBtn').addEventListener('click', () => this.processCroppedImage());
                
                // Confirm actions
                document.getElementById('saveReadingBtn').addEventListener('click', () => this.saveReading());
                
                // History management
                document.getElementById('clearHistoryBtn').addEventListener('click', () => this.clearHistory());
                
                // Error/Success message close
                document.getElementById('closeError').addEventListener('click', () => this.hideError());
                document.getElementById('closeSuccess').addEventListener('click', () => this.hideSuccess());
            }

            showScreen(screenId) {
                const screens = ['mainScreen', 'cameraScreen', 'cropScreen', 'ocrScreen', 'confirmScreen'];
                screens.forEach(id => {
                    const element = document.getElementById(id);
                    if (id === screenId) {
                        element.classList.remove('hidden');
                        element.classList.add('fade-in');
                    } else {
                        element.classList.add('hidden');
                        element.classList.remove('fade-in');
                    }
                });
            }

            showMainScreen() {
                this.cleanupCropper();
                this.showScreen('mainScreen');
            }

            showCameraScreen() {
                this.showScreen('cameraScreen');
                // Reset camera input
                document.getElementById('cameraInput').value = '';
            }

            async handleImageCapture(event) {
                const file = event.target.files[0];
                if (!file) return;

                try {
                    console.log('Image captured:', file.name, file.size, 'bytes');
                    
                    // Validate file type
                    if (!file.type.startsWith('image/')) {
                        this.showError('Please select a valid image file');
                        return;
                    }

                    // Validate file size (max 10MB)
                    if (file.size > 10 * 1024 * 1024) {
                        this.showError('Image too large. Please use an image smaller than 10MB');
                        return;
                    }

                    const imageUrl = URL.createObjectURL(file);
                    this.currentImage = imageUrl;
                    
                    await this.setupCropper(imageUrl);
                    this.showScreen('cropScreen');
                    
                } catch (error) {
                    console.error('Error handling image capture:', error);
                    this.showError('Failed to process image. Please try again.');
                }
            }

            async setupCropper(imageUrl) {
                return new Promise((resolve) => {
                    const image = document.getElementById('cropImage');
                    
                    this.cleanupCropper();
                    
                    image.src = imageUrl;
                    image.onload = () => {
                        this.cropper = new Cropper(image, {
                            aspectRatio: NaN,
                            viewMode: 1,
                            dragMode: 'crop',
                            autoCropArea: 0.8,
                            restore: false,
                            guides: true,
                            center: true,
                            highlight: false,
                            cropBoxMovable: true,
                            cropBoxResizable: true,
                            toggleDragModeOnDblclick: false,
                            responsive: true,
                            checkOrientation: false
                        });
                        resolve();
                    };
                });
            }

            cleanupCropper() {
                if (this.cropper) {
                    this.cropper.destroy();
                    this.cropper = null;
                }
            }

            async processCroppedImage() {
                if (!this.cropper) {
                    this.showError('No image to process');
                    return;
                }

                try {
                    this.showScreen('ocrScreen');
                    console.log('Starting OCR processing...');

                    // Get cropped canvas
                    const canvas = this.cropper.getCroppedCanvas({
                        width: 800,
                        height: 400,
                        imageSmoothingEnabled: true,
                        imageSmoothingQuality: 'high'
                    });

                    // Enhance image for OCR
                    const enhancedCanvas = this.enhanceImageForOCR(canvas);
                    
                    // Convert to blob for OCR
                    const blob = await new Promise(resolve => enhancedCanvas.toBlob(resolve, 'image/png'));
                    
                    // Perform OCR
                    const ocrResult = await this.performOCR(blob);
                    console.log('OCR completed:', ocrResult);
                    
                    // Show cropped preview
                    const previewUrl = enhancedCanvas.toDataURL();
                    document.getElementById('croppedPreview').src = previewUrl;
                    
                    // Set extracted reading
                    document.getElementById('readingInput').value = ocrResult;
                    
                    // Set current date/time
                    const now = new Date();
                    document.getElementById('currentDate').textContent = now.toLocaleDateString();
                    document.getElementById('currentTime').textContent = now.toLocaleTimeString();
                    
                    this.showScreen('confirmScreen');
                    
                } catch (error) {
                    console.error('Error processing cropped image:', error);
                    this.showError('Failed to extract reading. Please try again or enter manually.');
                    this.showMainScreen();
                }
            }

            enhanceImageForOCR(canvas) {
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;

                // Convert to grayscale and increase contrast
                for (let i = 0; i < data.length; i += 4) {
                    const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
                    
                    // Increase contrast
                    const contrast = 1.5;
                    const factor = (259 * (contrast * 255 + 255)) / (255 * (259 - contrast * 255));
                    const enhancedGray = Math.min(255, Math.max(0, factor * (gray - 128) + 128));
                    
                    data[i] = enhancedGray;     // Red
                    data[i + 1] = enhancedGray; // Green
                    data[i + 2] = enhancedGray; // Blue
                }

                ctx.putImageData(imageData, 0, 0);
                return canvas;
            }

            async performOCR(imageBlob) {
                try {
                    const worker = await Tesseract.createWorker();
                    
                    await worker.loadLanguage('eng');
                    await worker.initialize('eng');
                    
                    // Configure for number recognition
                    await worker.setParameters({
                        tessedit_char_whitelist: '0123456789.',
                        tessedit_pageseg_mode: '8' // Single word
                    });

                    const { data: { text } } = await worker.recognize(imageBlob);
                    await worker.terminate();

                    // Clean and validate the extracted text
                    const cleanedText = this.cleanOCRResult(text);
                    console.log('OCR raw result:', text, 'Cleaned:', cleanedText);
                    
                    return cleanedText;
                    
                } catch (error) {
                    console.error('OCR Error:', error);
                    throw new Error('OCR processing failed');
                }
            }

            cleanOCRResult(text) {
                // Remove all non-numeric characters except decimal points
                let cleaned = text.replace(/[^0-9.]/g, '');
                
                // Handle multiple decimal points (keep only the first one)
                const parts = cleaned.split('.');
                if (parts.length > 2) {
                    cleaned = parts[0] + '.' + parts.slice(1).join('');
                }
                
                // Remove leading zeros but preserve decimal values
                if (cleaned.includes('.')) {
                    const [whole, decimal] = cleaned.split('.');
                    cleaned = (parseInt(whole) || 0) + '.' + decimal;
                } else {
                    cleaned = (parseInt(cleaned) || '').toString();
                }
                
                return cleaned;
            }

            saveReading() {
                const reading = document.getElementById('readingInput').value.trim();
                
                if (!reading || isNaN(parseFloat(reading))) {
                    this.showError('Please enter a valid meter reading');
                    return;
                }

                try {
                    const newReading = {
                        id: Date.now(),
                        value: parseFloat(reading),
                        timestamp: new Date().toISOString(),
                        date: new Date().toLocaleDateString(),
                        time: new Date().toLocaleTimeString()
                    };

                    this.readings.unshift(newReading);
                    this.saveReadings();
                    
                    console.log('Reading saved:', newReading);
                    this.showSuccess(`Reading ${reading} kWh saved successfully!`);
                    
                    this.updateStats();
                    this.renderReadings();
                    this.showMainScreen();
                    
                } catch (error) {
                    console.error('Error saving reading:', error);
                    this.showError('Failed to save reading. Please try again.');
                }
            }

            loadReadings() {
                try {
                    // Note: In a real environment, you would use localStorage here
                    // For this demo, we'll use a session variable
                    if (!window.meterReadings) {
                        window.meterReadings = [];
                    }
                    return window.meterReadings;
                } catch (error) {
                    console.error('Error loading readings:', error);
                    return [];
                }
            }

            saveReadings() {
                try {
                    // Note: In a real environment, you would use localStorage here
                    window.meterReadings = this.readings;
                    console.log('Readings saved to memory storage');
                } catch (error) {
                    console.error('Error saving readings:', error);
                    this.showError('Failed to save data');
                }
            }

            updateStats() {
                document.getElementById('totalReadings').textContent = this.readings.length;
                const lastReading = this.readings.length > 0 ? this.readings[0].value + ' kWh' : '-';
                document.getElementById('lastReading').textContent = lastReading;
            }

            renderReadings() {
                const container = document.getElementById('readingsList');
                
                if (this.readings.length === 0) {
                    container.innerHTML = `
                        <div class="text-gray-500 text-center py-8">
                            No readings yet. Take your first photo!
                        </div>
                    `;
                    return;
                }

                container.innerHTML = this.readings.slice(0, 10).map(reading => `
                    <div class="reading-item bg-gray-50 p-3 rounded-lg border-l-4 border-blue-500">
                        <div class="flex justify-between items-start">
                            <div>
                                <div class="font-bold text-lg text-gray-800">${reading.value} kWh</div>
                                <div class="text-sm text-gray-600">
                                    üìÖ ${reading.date} ‚Ä¢ üïê ${reading.time}
                                </div>
                            </div>
                            <button onclick="meterApp.deleteReading(${reading.id})" 
                                    class="text-red-500 hover:text-red-700 text-sm"
                                    aria-label="Delete reading">
                                üóëÔ∏è
                            </button>
                        </div>
                    </div>
                `).join('');

                if (this.readings.length > 10) {
                    container.innerHTML += `
                        <div class="text-center text-gray-500 text-sm py-2">
                            ... and ${this.readings.length - 10} more readings
                        </div>
                    `;
                }
            }

            deleteReading(id) {
                if (confirm('Delete this reading?')) {
                    this.readings = this.readings.filter(r => r.id !== id);
                    this.saveReadings();
                    this.updateStats();
                    this.renderReadings();
                    this.showSuccess('Reading deleted');
                }
            }

            clearHistory() {
                if (confirm('Clear all readings? This cannot be undone.')) {
                    this.readings = [];
                    this.saveReadings();
                    this.updateStats();
                    this.renderReadings();
                    this.showSuccess('All readings cleared');
                }
            }

            showError(message) {
                document.getElementById('errorText').textContent = message;
                document.getElementById('errorMessage').classList.remove('hidden');
                setTimeout(() => this.hideError(), 5000);
            }

            hideError() {
                document.getElementById('errorMessage').classList.add('hidden');
            }

            showSuccess(message) {
                document.getElementById('successText').textContent = message;
                document.getElementById('successMessage').classList.remove('hidden');
                setTimeout(() => this.hideSuccess(), 3000);
            }

            hideSuccess() {
                document.getElementById('successMessage').classList.add('hidden');
            }

            async registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    try {
                        // Create a simple service worker inline
                        const swCode = `
                            self.addEventListener('install', (e) => {
                                console.log('Service Worker installed');
                            });
                            
                            self.addEventListener('fetch', (e) => {
                                e.respondWith(fetch(e.request));
                            });
                        `;
                        
                        const blob = new Blob([swCode], { type: 'application/javascript' });
                        const swUrl = URL.createObjectURL(blob);
                        
                        await navigator.serviceWorker.register(swUrl);
                        console.log('Service Worker registered for PWA capability');
                    } catch (error) {
                        console.log('Service Worker registration failed:', error);
                    }
                }
            }
        }

        // Initialize app when DOM is loaded
        let meterApp;
        document.addEventListener('DOMContentLoaded', () => {
            meterApp = new MeterReaderApp();
        });

        // Accessibility enhancements
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const currentScreen = document.querySelector('[id$="Screen"]:not(.hidden)');
                if (currentScreen && currentScreen.id !== 'mainScreen') {
                    meterApp.showMainScreen();
                }
            }
        });

        // PWA install prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            
            // Show install button
            const installBtn = document.createElement('button');
            installBtn.textContent = 'üì± Install App';
            installBtn.className = 'fixed bottom-4 right-4 bg-blue-600 text-white px-4 py-2 rounded-lg shadow-lg text-sm hover:bg-blue-700';
            installBtn.onclick = () => {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('PWA installed');
                    }
                    deferredPrompt = null;
                    installBtn.remove();
                });
            };
            document.body.appendChild(installBtn);
        });

        // Handle offline/online status
        window.addEventListener('online', () => {
            document.body.classList.remove('offline');
        });

        window.addEventListener('offline', () => {
            document.body.classList.add('offline');
        });

        // Touch gesture support
        let touchStartY = 0;
        document.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].clientY;
        });

        document.addEventListener('touchmove', (e) => {
            if (window.scrollY === 0 && e.touches[0].clientY > touchStartY + 50) {
                // Pull to refresh gesture
                if (meterApp && document.getElementById('mainScreen').classList.contains('hidden') === false) {
                    meterApp.updateStats();
                    meterApp.renderReadings();
                }
            }
        });
    </script>

    <!-- Offline indicator -->
    <style>
        .offline::before {
            content: "üì° Offline - Data saved locally";
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #f59e0b;
            color: white;
            text-align: center;
            padding: 8px;
            font-size: 14px;
            z-index: 100;
        }
        
        .offline {
            padding-top: 40px;
        }
    </style>
</body>
</html>